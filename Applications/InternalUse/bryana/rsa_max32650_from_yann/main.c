/*******************************************************************************
 * Copyright (C) 2018 Maxim Integrated Products, Inc., All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Maxim Integrated
 * Products, Inc. shall not be used except as stated in the Maxim Integrated
 * Products, Inc. Branding Policy.
 *
 * The mere transfer of this software does not imply any licenses
 * of trade secrets, proprietary technology, copyrights, patents,
 * trademarks, maskwork rights, or any other form of intellectual
 * property whatsoever. Maxim Integrated Products, Inc. retains all
 * ownership rights.
 *
 ******************************************************************************/

/**
 * @file    main.c
 * @brief   rsa_max3265x
 * @details This example uses the UART to show RSA example computations.
 */

/***** Includes *****/
#include <stdio.h>
#include <stdint.h>
#include "mxc_config.h"
#include "maa.h"
#include <string.h> // for memcmp()

/***** Definitions *****/
#define ARR_SIZE        512


void reverse(unsigned char *a,int byte_len)
{
  int i;
  unsigned char temp;

  for(i = 0;i < (byte_len/2);i++)
  {
    temp = a[byte_len-1-i];
    a[byte_len-1-i] = a[i];
    a[i] = temp;
  }
}

void bignum_d2us(unsigned char *a,unsigned int  len,unsigned int *b,unsigned digits)
{
  unsigned int t;
  int j;
  int i;
  unsigned int u;
  for(i = 0, j = 0; i <(int)digits && (j<(int)len); i++)
    {
      t = b[i];
      for(u = 0; j<(int)len && u <(int)32; j++, u += 8) {
        a[j] =(unsigned char)(t >> u);
      }
    }
}

int rsa(void)
{
  //this example encrypts a plain message m with a public exponent e modulus n
  //it also decrypts an encrypted message c with the private exponent d modulus n

  //the big numbers (modulus, exponent) are represented in natural way: first byte is ms byte
  //m is the message
  unsigned char m[]={0x11,0x22,0x33,0x44};
  //e is the public exponent = 65537
  unsigned char e[]={0x01,0x00,0x01};
  
  //d is the private exponent
  unsigned char d[]={0x24,0x89,0x10,0x8B,0x0B,0x6A,0xF8,0x6B,0xED,0x9E,0x44,0xC2,0x33,0x64,0x42,0xD5,0xE2,0x27,0xDB,0xA5,0x5E,0xF8,0xE2,0x6A,0x7E,0x43,0x71,0x94,0x11,0x90,0x77,0xF0,0x03,0xBC,0x9C,0x02,0x78,0x52,0xBB,0x31,0x26,0xC9,0x9C,0x16,0xD5,0xF1,0x05,0x7B,0xC8,0x36,0x1D,0xCB,0x26,0xA5,0xB2,0xDB,0x42,0x29,0xDB,0x3D,0xE5,0xBD,0x97,0x9B,0x2E,0x59,0x7D,0x19,0x16,0xD7,0xBB,0xC9,0x27,0x46,0xFC,0x07,0x59,0x5C,0x76,0xB4,0x4B,0x39,0xA4,0x76,0xA6,0x5C,0x86,0xF0,0x86,0xDC,0x92,0x83,0xCA,0x6D,0x1E,0xEF,0xC1,0x49,0x15,0x98,0x2F,0x9C,0x4C,0xED,0x5F,0x62,0xA9,0xFF,0x3B,0xE2,0x42,0x18,0xA9,0x93,0x57,0xB5,0xB6,0x5C,0x3B,0x10,0xAE,0xB3,0x67,0xE9,0x11,0xEB,0x9E,0x21};


  //n is the modulus
  unsigned char n[]={0xF0,0xC4,0x2D,0xB8,0x48,0x6F,0xEB,0x95,0x95,0xD8,0xC7,0x8F,0x90,0x8D,0x04,0xA9,0xB6,0xC8,0xC7,0x7A,0x36,0x10,0x5B,0x1B,0xF2,0x75,0x53,0x77,0xA6,0x89,0x3D,0xC4,0x38,0x3C,0x54,0xEC,0x6B,0x52,0x62,0xE5,0x68,0x8E,0x5F,0x9D,0x9D,0xD1,0x64,0x97,0xD0,0xE3,0xEA,0x83,0x3D,0xEE,0x2C,0x8E,0xBC,0xD1,0x43,0x83,0x89,0xFC,0xCA,0x8F,0xED,0xE7,0xA8,0x8A,0x81,0x25,0x7E,0x8B,0x27,0x09,0xC4,0x94,0xD4,0x2F,0x72,0x3D,0xEC,0x2E,0x0B,0x5C,0x09,0x73,0x1C,0x55,0x0D,0xCC,0x9D,0x7E,0x75,0x25,0x89,0x89,0x1C,0xBB,0xC3,0x02,0x13,0x07,0xDD,0x91,0x8E,0x10,0x0B,0x34,0xC0,0x14,0xA5,0x59,0xE0,0xE1,0x82,0xAF,0xB2,0x1A,0x72,0xB3,0x07,0xCC,0x39,0x5D,0xEC,0x99,0x57,0x47};

  //c is the ciphertext, encryption of m
  unsigned char c[]={0x50,0x5B,0x09,0xBD,0x5D,0x0E,0x66,0xD7,0xC8,0x82,0x9F,0x5B,0x47,0x3E,0xD3,0x4D,0xB5,0xCF,0xDB,0xB5,0xD5,0x8C,0xE7,0x83,0x29,0xC8,0xBF,0x85,0x20,0xE4,0x86,0xD3,0xC4,0xCF,0x9B,0x70,0xC6,0x34,0x65,0x94,0x35,0x80,0x80,0xF4,0x3F,0x47,0xEE,0x86,0x3C,0xFA,0xF2,0xA2,0xE5,0xF0,0x3D,0x1E,0x13,0xD6,0xFE,0xC5,0x7D,0xFB,0x1D,0x55,0x22,0x24,0xC4,0x61,0xDA,0x41,0x1C,0xFE,0x5D,0x0B,0x05,0xBA,0x87,0x7E,0x3A,0x42,0xF6,0xDE,0x4D,0xA4,0x6A,0x96,0x5C,0x9B,0x69,0x5E,0xE2,0xD5,0x0E,0x40,0x08,0x94,0x06,0x1C,0xB0,0xA2,0x1C,0xA3,0xA5,0x24,0xB4,0x07,0xE9,0xFF,0xBA,0x87,0xFC,0x96,0x6B,0x3B,0xA9,0x45,0x90,0x84,0x9A,0xEB,0x90,0x8A,0xAF,0xF4,0xC7,0x19,0xC2,0xE4};

  unsigned char eext[ARR_SIZE];
  unsigned char mext[ARR_SIZE];
  unsigned char one[ARR_SIZE];
  unsigned int result[ARR_SIZE];
  unsigned char resuchar[ARR_SIZE];
  int modulus_byte_len = sizeof(n);
  int retval, i;

  printf("\n***** RSA Example using the MAA *****\n");
  printf("Modulus size: %d\n",modulus_byte_len*8);

  // Initialize crypto block
  MAA_Init(modulus_byte_len*8);

  // Initialize big numbers.
  memset(one,0,modulus_byte_len);
  one[0] = 1;
  memset(mext,0,modulus_byte_len);
  memset(eext,0,modulus_byte_len);
  for(i=0;i<sizeof(m);i++)
  {
    mext[i]=m[sizeof(m)-1-i];
  }
  for(i=0;i<sizeof(e);i++)
  {
    eext[i]=e[i];
  }

  reverse(c,modulus_byte_len);
  reverse(d,modulus_byte_len);
  reverse(n,modulus_byte_len);

  // Compute MAA
  retval = MAA_Compute(TPU_MAA_EXP, (char *)mext, (char *)one, (char *)eext, (char *)n, (int *)result, modulus_byte_len);
  if (retval != E_SUCCESS)
  {
    printf("Failed MAA_Compute().\n");
    return -1;
  }
  
  bignum_d2us(resuchar,modulus_byte_len,result,modulus_byte_len/4);
  if(memcmp(resuchar,c,modulus_byte_len)!=0) {
    printf("Error: invalid ciphertext\n");
  } else {
    printf("Correct ciphertext\n");
  }

  retval = MAA_Compute(TPU_MAA_EXP, (char *)c, (char *)one , (char *)d, (char *)n, (int *)result, modulus_byte_len);
  if (retval != E_SUCCESS) {
    printf("Failed MAA_Compute().\n");
    return -1;
  }

  bignum_d2us(resuchar,modulus_byte_len,result,modulus_byte_len/4);
  if(memcmp(resuchar,mext,modulus_byte_len)!=0) {
    printf("Error: invalid plaintext\n");
  } else {
    printf("Correct plaintext\n");
  }

  return 0;
}

// *****************************************************************************
int main(void)
{
  printf("\n***** RSA Example using the MAA *****\n");
  
  rsa();

  printf("Example complete.\n");

  while(1) {}
}
